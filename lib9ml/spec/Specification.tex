\documentclass{article}

\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{color}

\definecolor{INCFBlue}{rgb}{0.0,0.59,1.0}

\definecolor{issuecolor}{rgb}{0.8,0.8,0.8}
\newcommand{\issue}[1]{%
\begin{center}
\colorbox{issuecolor}{\parbox{0.8\linewidth}{\textbf{Issue:} #1}}
\end{center}%
}

\newcommand{\suggestion}[2]{%
\begin{center}
\colorbox{issuecolor}{\parbox{0.8\linewidth}{\textbf{#1:} #2}}
\end{center}%
}

\newcommand{\nmlClass}[1]{{\tt #1}}

\begin{document}

\pagestyle{empty}

\begin{center}
\includegraphics[width=0.7\columnwidth]{./images/incf.png}
\end{center}

\vspace*{1cm}

\noindent\rule{\columnwidth}{1pt}
\noindent\rule{\columnwidth}{2pt}

\vspace*{1cm}

\begin{center}

\noindent{\Huge \bf Network Interchange for Neuroscience Modeling Language (NineML)\\
\vspace{0.5cm}
\noindent{\Large \bf Specification}\\
\vspace{0.5cm}
\noindent{\large INCF Task Force on Multi-Scale Modeling}\\
\vspace{0.5cm}
\noindent{\large Version: 0.94}

\end{center}

\vspace*{0.75cm}

\noindent\rule{\columnwidth}{2pt}
\noindent\rule{\columnwidth}{1pt}

\vspace*{3cm}
\noindent{\Large

\begin{center}
{\bf Authors (in alphabetical order): }
\end{center}

\noindent Hugo Cornelis, Andrew Davison, Mikael Djurfeldt, Anatoli
Gorchetchnikov, Sean Hill, Eilif Muller, Ivan Raikov \\

%\vspace*{0.5cm}

\noindent {\bf Date:} \today

}


\title{NineML (9ML) Specification}

\newpage
\pagestyle{plain}

\tableofcontents
\newpage

\abstract
This document formalizes the cuttently developed concepts of NineML.

This work summarizes the decisions made during eight Task Force meetings
and group discussions. This specification is created for public release
at CNS 2011.

\vskip 1in

\paragraph{Changes from version 0.93:}
\begin{itemize}
\item Combined User and Abstraction layer specifications into a single document
\item Cut out the group and set sections since they are not part of the release
\end{itemize}

\paragraph{Changes from version 0.92:}
\begin{itemize}
\item Adapted the format similar to the Abstraction layer specification.
I think this document shall essentially become user layer section of the
general specification document.
\item Attempted to reorganize and adapt the text to be more like ``Object
Model'' for the User Layer.
\end{itemize}

\paragraph{Changes from version 0.91:}
\begin{itemize}
\item Replaced ``node'' with ``component'' as was decided in Antwerp 2010
meeting.
\item Replaced references to ``core semantics'' with references to
``abstraction layer''
because the term ``core semantics'' is no longer used.
\item As Antwerp 2010 decided, properties are represented by a generic
tag and specified
by attribute {\tt name}.
\item Added the reference to units of measurements dimensionality checking
against
the abstraction layer as was decided in Antwerp 2010.
\item Moved edge effect descriptions from connectivity components to layout
components. Also
noted that some layouts might require complex masks.
\end{itemize}

\paragraph{Changes from version 0.9:}
\begin{itemize}
\item added footnotes for some issues raised in Stockholm June meeting
\item added brief description of interactions between user layer and
simulation software that does not support abstraction layer
\item removed random number generator nodes as decided in Stockholm
\item added space, region, and layout nodes as a first draft of geometrical
concepts (based on NetworkML proposal by Padraig and Robert as well as
Stockholm discussions)
\item removed recurrent projections that can be described on the population
level
\item cut out the previous approach to cell positioning within population
\end{itemize}
\newpage

\section{Introduction}

With an increasing number of studies related to large-scale neuronal
network modeling, the International Neuroinformatics Coordinating
Facility (INCF) has identified a need for standards and guidelines to
ease model sharing and facilitate the replication of results across
different simulators. To create such standards, the INCF has formed a
program on Multiscale Modeling to develop a common standardized
description language for neuronal network models.

The name of the proposed standard is NineML (Network Interchange for
Neuroscience Modeling Language) and its first version is aimed at
descriptions of large networks of spiking neurons.

\subsection{Scope}

The purpose of NineML is to provide a computer language for
succinct and unambiguous description of computational neuroscience models of
networks of spiking neurons.

NineML is intended to describe the network architecture, parameters
and equations that govern the dynamics of a network of spiking
neurons. The behavioral aspects of such a system, such as input
stimulus, and the numerical implementation details, such as
integration method used, have to be described using different
techniques.  Model description in NineML is intended to be formal in
the sense that it is possible to interpret it unambiguously.

\subsection{Objective}

The key concepts of spiking neuron network modeling are:

\begin{enumerate}
\item spiking neurons
\item synapses
\begin{enumerate}
\item Post-synaptic membrane current mechanisms
\item Short-term synaptic dynamics (a la Markram et. al. 1998)
\item Long-term synaptic modifications (STDP, learning, etc.)
\end{enumerate}
\end{enumerate}

Accordingly, NineML defines a set of mathematical abstractions that
are capable of representing these concepts.

\subsection{Design Considerations}

\subsubsection{User layer and Abstraction layer}

The design of NineML is divided into two semantic layers: an abstraction
layer that provides the core
concepts, mathematics and syntax with which model variables and state
update rules are explicitly described, and a user layer that provides a
syntax to specify the instantiation and parameterization of a network
model in biological terms.

The user layer provides the syntax for specifying the model and parameters to
be used to instantiate the key elements of a spiking neuronal network in terms
that are directly linked to the biological counterparts of the model. This
includes descriptions of individual elements (cells, synapses, inputs).
As the User Layer provides the mechanism for instantiating and
parameterization of the model elements that have been defined in the
Abstraction Layer, it is clearly essential that these two layers share
a complementary and compatible design philosophy. There must be a
clear definition of which aspects of a model are defined in the User
Layer and which are defined in the Abstraction Layer. In addition, the
mechanisms and syntax for naming and addressing Abstraction Layer
concepts that are instantiated in the User Layer to keep things simple
for the user.

\subsubsection{Implementation assumptions}

One of the goals identified by task force members, was to maintain a
clear distinction between the role of NineML and a simulator. NineML
should provide only the information necessary for any given simulator
to instantiate the network models in a simulator agnostic way.  For
example, NineML should specify the neuron membrane equation to solve,
but not how to solve it.  In addition, for implementation and
performance reasons, it is important to keep the language layer
``close'' to the simulator – such that the language layer is not
responsible for maintaining separate representations of the
instantiated network.

\subsubsection{Language syntax}

It is envisioned that the language should not require a
specific syntax or rely on any given technology or platform.
Rather it is anticipated that the language can be
employed by defining the model elements in a variety of different
syntaxes including a native (domain specific) language, Python, Java,
and XML (for example).

\subsection{Object Model, Native Language, and XML Serialization}

The NineML specification consists of an Object Model, and an XML serialization
format. The NineML Object Model specifies the data types, core and derived
concepts of NineML and the object-oriented interface to them. The NineML
XML format specifies how a NineML compliant program is to parse and emit
NineML in a XML structured document.  The NineML XML schema is
isomorphic to the NineML object model.

The NineML object model, and XML schema are discussed in turn in the
following sections.

A NineML object model representation then can take multiple forms.  A
program can employ a concrete representation of the NineML objects in
a specific programming language, or it can convert an internal model
representation to and from the NineML XML schema, or it can take the
form of an interpreter for the NineML native language as a compact
representation and use code generation to produce a model
representation for a target simulation environment.

\section{Core Concepts}

In this section, we start by laying the foundation of the NineML
that include data types and core building blocks.

heirarchical Namespace scheme used to unambigiously address elements
of a given NineML model.  We then proceed to define the elements
which populate Namespaces to make up an Abraction Layer model and
provide primitives that allow to instantiate this model in the User
Layer. This instantiation is based on five key elements: data types,
property, definition, component, and projection.

\subsection{Data types}
\label{DataTypes}

Values in NineML can have different types, which are listed in the
following subsections. Data types are the objects that allow the
encapsulation of value data and are not intended as standalone
objects outside of {\tt Binding} objects in the Abstraction Layer or
{\tt property} objects in the User Layer.

\subsubsection{Dimension}

Dimension is an object that provides physical dimension like length,
mass, or time. A set of predefined dimensions is provided in the
NineML library and the user can derive compound dimensions from these
(for example velocity is derived from length and time). A special case
of a {\tt Dimension} is a predefined empty dimension for dimensionless
quantities.

\subsubsection{Counter}

Counter is an object that represent the countable quantity (natural
number) and is used to define a number of identical objects that have
to be instantiated in a model from a single object definition (for
example a number of neurons in a population of identical cells).

\subsubsection{Number}

Number is a object that represents numerical values. It is not designed for
a direct use, but rather as a component of the {\tt Quantity} type that
additionally includes the units of measurements for each specific quantity.

\subsubsection{String}

String is an object that contains a string of text. It is used for labeling
elements as well as for optional textual {\tt note}s that annotate these
elements.

\subsubsection{URL}

URL is an object that contains a reference to an internet resource in a form
of a URL. It is used for abstraction layer or external definitions as well as
for links in optional {\tt note}s that annotate these elements.

\subsubsection{Enumerated}

Enumerated is an object that is used for properties that can only take
a few predefined by abstraction layer values.

\subsubsection{Boolean}

Boolean is an object that contains a binary true-false value or a logical
expression that can be evaluated into such a value.

\subsubsection{Function}

Function is an object that returns a value of a {\tt Number} type resulting
from calculation that can be deterministic or based on random number
distribution.

\subsubsection{Quantity}

Quantity is a compound data type object that encapsulates a numerical value
and a unit of measurements. Unit has to be of one of the {\tt Dimension} type.
Any numeric quantity in the language (except counters) has to be of this type,
dimensionless quantities shall use predefined empty {\tt Dimension}.

\begin{table}[htb]
\center
\begin{tabular}{|c|}
\hline
\hline
Quantity \\
\hline
\hline
{\em unit}: {\tt Dimension} \\
\hline
{\em value}: \{{\tt Number}$|${\tt Function}$|$%
{\tt Component->Random Distribution}\} \\
\hline
\end{tabular}
\end{table}

There are two kinds of quantities: values of the first kind are given to the
model by the user and stay fixed, values of a second kind are computed within
the model during simulation. For all practical reasons the syntax of the user
layer descriptions is identical for both kinds of quantities. Furthermore,
because NineML does not provide any default values for quantities, it is a
job of the user to provide initial values for all defined quantities. To
ensure the integrity of the model NineML requires all initial values to be
set in the user layer description. For batch simulations and other
modifications any of the values given in the user layer can be overwritten
by a simulation setup description, but this is outside of the scope of the
current version of NineML.

Some quantities can have values drawn from random distribution. In this case
user layer description of the quantities includes a reference to a random
distribution component (section~\ref{randDist}) instead of a numeric value.
Other quantities might be calculated according to some function dependent on
some other quantities. These can be defined through the type {\tt Function} by
including inline abstraction layer definitions or MathML.

\subsubsection{Other compound types}

Copied from AL spec since I do not have Gif minutes. AG.

[TODO: ... see Gif

Constant/Primitives
Compound Types:
- Diagrams
- Relation (Local functions for ``:='' in python) [I think this is covered above. AG]
- Graphs
- CSA

- Closure/Python: ''Component Factory'' (mention here, refer to following section)
  an intermediate value to represent Compound types with
  unspecified internal values.


[Sub-TODO: ComponentType/ComponentInterface ... probably not a
value, but rather a ``meta value'' ... where to talk about it ...]


Sub-typing system

See gif day2 minutes ... and write this section.
Who gives it a go: Ivan
]

\subsection{Binding}

A fundamental aspect of the organization of most programming languages
is to use names to refer to computational entities.  Likewise, to each
computational element of NineML, refered to as \emph{values}, we
assign a name, referred to as a NineML \emph{label}. As such, we say
that labels identify values.

In the NineML abstraction layer, the act of assigning a label to a value
is achieved with the {\tt Binding} object:

\begin{table}[htb]
\center
\begin{tabular}{|c|}
\hline
\hline
Binding \\
\hline
\hline
{\em Label}: {\tt String} \\
\hline
{\em Value}: any Data Type (sec.~\ref{DataTypes}) \\
\hline
\end{tabular}
\end{table}

Once a label is declared in a binding, its associated value can be
reached by other bindings in the program, according to the scoping
rules of the NineML {\tt Namespace} object, as described later in
this document.

The interface to a binding object must provide the following methods:
\begin{equation*}
\begin{array}{ll}
   \mathbf{label} & :: Binding \rightarrow Label \\ & \textrm{[Returns the label of a binding]} \\
   \mathbf{value} & :: Binding \rightarrow Value \\ & \textrm{[Returns the value of a binding]} \\
\end{array}
\end{equation*}

\subsection{Namespaces}

A NineML Abstraction Layer namespace is an ordered collection of
bindings and sub-namespaces.

\subsubsection{NameEntry}

NameEntry is a compound object that is either a binding or a
label/{\tt Namespace} pair referring to sub-namespace.
[unclear to me why not just allow Bindings to
have Namespace as value and eliminate NameEntry alltogether. AG]

\begin{table}[htb]
\center
\begin{tabular}{|c|}
\hline
\hline
NameEntry \\
\hline
\hline
{\em Label}: {\tt String} \\
\hline
{\em Value}: \{any Data Type (sec.~\ref{DataTypes})$|${\tt Namespace}\} \\
\hline
\end{tabular}
\end{table}

\subsubsection{Namespace}

\begin{table}[htb]
\center
\begin{tabular}{|c|}
\hline
\hline
Namespace \\
\hline
\hline
\colorbox{issuecolor}{\parbox{0.4\linewidth}
{\center Set of {\tt NameEntry} objects}} \\
\hline
\end{tabular}
\end{table}

\begin{itemize}
\item A value in a binding must not refer to a name that is not in the
  current namespace scope.
\item All entries in a namespace (at the same scope) have distinct
  names. For example, a namespace \verb^C^ cannot have two members
  named \verb^m^, because we would not know which type \verb^C.m^
  refers to.
\item Sub-namespaces can still have entries with the same name as
  entries from an outer enclosing namespace. For instance, \verb^C^
  can have an entry \verb^m^ and a sub-namespace \verb^D^ with another
  entry \verb^m^.  The former entry \verb^m^ is referred to as
  \verb^C.m^, and the latter as \verb^C.D.m^.
\end{itemize}

The interface to a binding object must provide the following methods:
\begin{equation*}
\begin{array}{ll}
   \mathbf{find}  & :: Namespace \times AccessPath \rightarrow
   NameEntry \cup \emptyset \\
   & \textrm{[Returns an entry with the given access path from a namespace]} \\
   \mathbf{signature}  & :: Namespace \rightarrow (Label \times Type) \quad collection \\
   & \textrm{[Returns the types of all entries in the namespace]} \\
\end{array}
\end{equation*}

[What does Type refer to in this expression? Is it Data Type or something
more elaborate? AG.]

\subsubsection{Access Paths for Nested Namespaces}

\begin{equation*}
\begin{array}{ll}
   AccessPath & ::= Label  \quad \lvert \quad AccessPath \times Label \\
\end{array}
\end{equation*}

[Did you mean {\tt NameEntry.Label} in this expression? AG.]

Since {\tt Namespace}s can be nested, names in
sub-{\tt Namespace}s of the current scope can be accessed via dot
notation, e.g. \verb^M.x^ to refer to the member \verb^x^ of container
\verb^M^.

\subsection{StateVariable}

\subsection{Parameter}

\subsection{Propagator}

\subsubsection{Equation}

NineML presently defines the following equation types: \nmlClass{ODE} and
\nmlClass{Assignment}. Each of these \nmlClass{Equation} sub-types must
define its left-hand-side (lhs) and right-hand-side (rhs), where
it is the lhs which differs for each of the equation types above.

\begin{table}[htb]
\center
\begin{tabular}{|c|}
\hline
\hline
ODE \\
\hline
\hline
{\em DependentLHS}: {\tt Quantity} \\
\hline
{\em IndependentLHS}: {\tt Quantity} \\
\hline
{\em RHS}: {\tt Function} \\
\hline
\end{tabular}
\end{table}

For example:
\begin{verbatim}
dx/dt = -x/tau
\end{verbatim}
In this \nmlClass{ODE}, the dependent variable is \verb^x^, the independent
variable is \verb^t^, and the rhs is \verb^-x/tau^.

[Shall there be a binding of LHS variable quantity to label? Maybe both are
bindings of label/Quantity pairs? AG.]

\begin{table}[htb]
\center
\begin{tabular}{|c|}
\hline
\hline
Assignment \\
\hline
\hline
{\em LHS}: {\tt Quantity} \\
\hline
{\em RHS}: {\tt Function} \\
\hline
\end{tabular}
\end{table}

For example:
\begin{verbatim}
x = sin(t)+10
\end{verbatim}
In this \nmlClass{Assignment}, the assigned variable is \verb^x^, and the rhs
is \verb^sin(t)+10^.

Note that {\tt Quantity} LHS variables is limited with respect that
{\tt Quantity.value} is only used to set the initial value of the variable
from a User Layer description and after that is determined within a simulator
from RHS (or internal clock for independent time variable) and has the type
{\tt Number}.

In all cases, the rhs is a nested tree of functions, \nmlClass{Bindings},
and arguments, where the functions are drawn from the component library
available to the model, as discussed in section \ref{nml_lib}, and arguments
can be of type \nmlClass{Parameter} or \nmlClass{StateVariable}.

\subsection{Ports}

There are two sub-classes of \nmlClass{Port} objects: \nmlClass{AnalogPort}
and \nmlClass{EventPort}.

% TODO
Modes: reduce, send, recv.
Reduce operations: add, mul, etc.

% TODO
Connection rules for ports of different types.

[TODO:
Flesh this out based on current implementation, taking into account
discussion we had in Stockholm on Interface defn containing all Ports,
Conditions now only refer to the event port by name.
Who: Eilif
]

\subsubsection{AnalogPort}

\subsubsection{EventPort}

\subsection{Regime}

A \nmlClass{Regime} is defined in NineML as a system of ODEs in time on
state variables.  As such, Regimes define how the state variables
change (propagate in time) between subsequent \nmlClass{Transitions}.
Regimes are defined to have non-vanishing temporal extent.  Once
construction of the Regime is complete, it should have defined the
following properties:

\begin{itemize}
\item An unordered collection of \nmlClass{StateVariable}s which are
propagated when the \nmlClass{Regime} is active.
\item A propagator for each state variable, $x_i$, presently in the
  form of an \nmlClass{ODE} of the form $dx_i/dt = f(x_0, ..., x_i, t)$.
%\item references to Transitions
\item user parameters for the \nmlClass{Regime}
\item An unordered collection of \nmlClass{AnalogPort}s which publish state
variables (type=send), or consume state variables published from elsewhere
(type=recv, or type=reduce).
\item The independent variable must be shared between the collection
of State Variables and their propagators in a Regime.
\end{itemize}

[TODO:
Sean's comment:
We should not perclude other systems of equations,
overrideing regime, spatial regimes ...

Generalize ODEs to general propagators ...
ODE is a special case of a propagator ...
Independent variable
Who: Ivan.
]

[TODO: Hybrid state machine as Appendix to clearly define Regime
in terms of atomic lower-level primitives.
Who: Ivan
]

[TODO:
TemporalRegime vs Regime ...
For this Developer release, Regimes are Temporal Regimes.
Who: not assigned until after CNS
]

\subsection{Condition}

\nmlClass{Condition}s are the mathematical expressions which define
when a \nmlClass{Transition} should be triggered.
\nmlClass{Condition}s are any arbitrary combination of \emph{Logical
  Operations} (see \ref{nml_lib}) (and/$\&$,or/$|$,noop,etc.) on the
result of any arbitrary combination of \emph{Relational Operations}
(see \ref{nml_lib}) ($>$,$<$,$==$,$<=$,$>=$, etc.) on \nmlClass{Equation}s.
At any given time in the \nmlClass{Regime}, the \nmlClass{Condition}
expression then evaluates to True or False {\tt Boolean} result.
For example, the following are valid \nmlClass{Condition}s

\begin{verbatim}
x>10
x>10 & y<20
x>exp(-cos(y)) | y<sin(t)+5
x==15
\end{verbatim}

A \nmlClass{Condition} which persistently evaluates to True
violates the definition that \nmlClass{Tranisiton}s should have vanishing
temporal extent, and there behaviour for this case is undefined, but
it would be preferable for the implementation to produce an error
message to the user.

\subsection{Transition}

A \nmlClass{Transition} is defined in NineML as having a source and target
\nmlClass{Regime}, where the target \nmlClass{Regime} can be the same as the source, a
\nmlClass{Condition} for triggering the \nmlClass{Transition}, and an ordered sequence of
operations on \nmlClass{StateVariable}s which carried out on occurence of the
\nmlClass{Transition}.  \nmlClass{Transition}s therefore are defined to have a vanishing
temportal extent (i.e. they are event-like).  Once construction of a
\nmlClass{Transition} is complete, it should have defined the following properties:
\begin{itemize}
\item The \nmlClass{Condition} or \nmlClass{EventPort(mode=recv)} which triggers the \nmlClass{Transition}
\item An ordered sequence of \nmlClass{Assignment}s or
  \nmlClass{EventPort(mode=send)} objects (causing an event to be published, for example, a spike).
\item The label of the source \nmlClass{Regime}, and the label of the target
  \nmlClass{Regime}, which may be the same as the source \nmlClass{Regime}.
\end{itemize}

[TODO:
Appendix with formal description in terms of primitive operations.
Who: Ivan
]

[TODO:
Raised by Mikael Djurkfeldt: Inheritance
Idea could be used for solving port conventions for:
STDP, DynSyn, Synaptic Current, MembraneDynamics
]

[TODO:
Idea raised Mikael: Syntax for state variables pre and post
transition for cleaning up explicit sequence in port connectivity
]

\subsection{Container}

\subsection{ComponentType}

Tying all these concepts together into the final resulting model is
the purpose of the {\tt ComponentType} object. The {\tt ComponentType} then
is the conglomerating object which is the subject of interaction with the
\textbf{User Layer}. To allow for modular composition of {\tt ComponentType}s
from sub-{\tt ComponentType}s, and to avoid name collision with symbols and
functions provided in standard libraries, a mechanism of namespace
encapsulation is required, and implemented by the {\tt Namespace} object
discussed previously.

[TODO: Component Interface, which contains declaration of statevars,
parameters, ports, and their units, or at least dimensions.]

[TODO: Specialized Interfaces for NetworkElementModel, ConnectivityModel,
etc., or even more specific SynapseModel, STDPModel, etc.]

% For now, no nested interfaces, but indeed nested namespaces.

%After construction, a {\tt Component} must define the following properties:

\subsubsection{NetworkElementModel Interface}
A {\tt Component} which exposes the NetworkElementModel
{\tt Interface} must contain the following:
\begin{itemize}
\item An unordered collection of {\tt Transition}s which connect the {\tt Regime}s
  of the {\tt Component} by assigning sources and targets from the named
  collection of {\tt Regime}s.

\item A {\tt Container} object which contains an unordered named collection of
\begin{itemize}
\item sub-{\tt Container} objects (may be user defined, or imported from the NineML standard libraray (see Section \ref{nml_lib}).
\item at least one {\tt Regime} in the {\tt Container} or its sub-{\tt Container}s.
\item {\tt StateVariable}s.
\item {\tt Parameter}s.
\item {\tt EventPort}s.
\item {\tt AnalogPort}s.
\item {\tt Binding}s.
\end{itemize}

The following points are to be observed:
\begin{itemize}
\item All {\tt StateVariable} symbols defined by the
  {\tt Regime}s in the {\tt Component} should be by default
  exposed in the collection of {\tt AnalogPort} objects with
  mode=send.
\item All objects in a {\tt Container}, such as
  {\tt Regime}s, {\tt Equation}s, {\tt Port}s, etc. do
  name look-up in the {\tt Component} {\tt Container}
  hierarchy using the {\tt Container} they are contained in for
  the root scope.
\item {\tt Condition}s, and source and target {\tt Regime}
  names in the {\tt Component} {\tt Transition}s do name
  look up with scoping as if they are contained in the Component root
  Container.
\end{itemize}

Implementations of the object model will likely want to provide
query/filter methods for Containers, such that all names of a given
type (e.g. {\tt EventPort}) are returned.

\end{itemize}

\subsection{Property}

Property is a User Layer object that instantiates values in simple
Abstraction Layer {\tt Binding}s and combines a value of one of the data
types defined in the section~\ref{DataTypes}, an indicator of the used type
[not in the table below, is it necessary? AG.],
and a label. The label should match the corresponding label in the
Abstraction Layer {\tt Binding} definition.

\begin{table}[htb]
\center
\begin{tabular}{|c|}
\hline
\hline
Property \\
\hline
\hline
{\em label}: {\tt String} \\
\hline
{\em value}: \{{\tt Quantity}$|${\tt Boolean}$|${\tt Enumerated}\} \\
\hline
{\em note}: \{{\tt String}$|${\tt URL}\} (optional)\\
\hline
\end{tabular}
\end{table}

The user can set the value of the property and (when applicable for the data
type, e.g. {\tt Quantity}) the units of measurement. These units are also
checked against the dimensionality of the corresponding property definition
in the abstraction layer.

User can add a note to a property. These notes are
intended to provide a specific reference to the research paper page
where the component is described and similar kind of information. These
notes are not intended to duplicate the abstraction layer documentation
or any other documentation, thus they shall not provide mathematical
description and other details of the component implementation. Note can
contain text (type {\tt String}) or link to an Internet resource (type
{\tt URL}).

\subsection{Definition}

All constructs in the user layer have their mathematical or algorithmical
definitions in the abstraction layer. Definition is an object that
establishes a link between user layer and abstraction layer. The initial
version of NineML allows to put references to external (including user
space abstraction layer) definitions.

\begin{table}[htb]
\center
\begin{tabular}{|c|}
\hline
\hline
Definition \\
\hline
\hline
{\em language}: {\tt String} \\
\hline
{\em link}: {\tt URL}\\
\hline
\end{tabular}
\end{table}

The language should be flexible enough to allow representation of concepts
that do not yet exist, as it is developed to serve the forefront of research.
A simple mechanism to add concepts that are not part of the standard is
provided through external (other than abstraction layer based) definitions.
It is the choice of a simulator developer to support these definitions during
initial stage of NineML development. Future
maturation of NineML shall eliminate the need to support simulator-specific
definitions.

\subsection{Reference}

Reference is an object that can replace {\tt Definition} object in situations
where user needs to reuse the same definition for multiple instances of
objects. In this case the first instance shall be described using
{\tt Definition} and the rest can use the first one through {\tt Reference}.
Label in the {\tt Reference} must match a label in a previously defined
object.

\begin{table}[htb]
\center
\begin{tabular}{|c|}
\hline
\hline
Reference \\
\hline
\hline
{\em label}: {\tt String} \\
\hline
\end{tabular}
\end{table}

\subsection{Component}

The basic building block of NineML is called component. In the user layer
description component is a reference to an object defined in the abstraction
layer. Abstraction layer defines the mathematics of the component and this
definition is then referred in the user layer through an object of type
{\tt Definition}.

\begin{table}[htb]
\center
\begin{tabular}{|c|}
\hline
\hline
Component \\
\hline
\hline
{\em label}: {\tt String} \\
\hline
{\em definition}: \{{\tt Definition}$|${\tt Reference}\}\\
\hline
{\em note}: \{{\tt String}$|${\tt URL}\} (optional)\\
\hline
\colorbox{issuecolor}{\parbox{0.4\linewidth}
{\center Set of {\tt Property} objects}} \\
\hline
\end{tabular}
\end{table}

In addition to the {\tt Definition} object, the component encapsulates
user-given ID or label, and a set of {\tt Property} objects. The composition
of this set of properties is defined in the abstraction layer (or externally)
and instantiated in the user layer description of component. The mapping
between mathematical description of the object in the abstraction
layer and the corresponding properties labels in the user layer are
provided in this specification.

User can add short notes to each component's description similar to
notes described above for properties.

To reduce the size of the resulting model description user can refer to
already described component by referencing their label instead of providing
a link to the abstraction layer or external definition. In this case the
properties of the component that have to be redefined are stated explicitly,
the properties that are inherited from the original description are omitted.

If the simulator only supports user layer, then the simulator developers
can create mappings directly between the reference to a definition in the
user layer description of the component and the intrinsic simulator code
that implements the same mathematics.

\subsubsection{Random Distribution Components}
\label{randDist}

This component allows to define random distribution with corresponding
parameters. These component allows the reuse of the same distribution
multiple times similar to reuse of all other components.

\subsubsection{Neuronal Components}
\label{neuron}

The description of the neuronal component defines a prototypical neuron
which can be reused multiple times within the network. As a consequence,
multiple connectivity patterns can be applied to this neuron, which
results in a different set of synaptic inputs. Therefore, no description
of these inputs shall be provided at the component level, they shall be
described at the projection level (Section \ref{projections}). Simulation
software shall take care of complete construction of each neuron by
analyzing both levels of description.

\subsubsection{Plasticity Components}
\label{plasticity}

Plasticity components handle the synaptic weight and its possible
modification. Note that synaptic weight is a dimensionless quantity and
as such always have units of the predefined empty {\tt Dimension}. This
is done to allow same plasticity rules to operate on
different types of postsynaptic responses. Synaptic weight defined in the
plasticity component determines only the magnitude of the response, the
shape and physical properties are defined in the corresponding post-synaptic
response node (section \ref{secSynapse}).

\subsubsection{Post-synaptic Response (PSR) Components}
\label{secSynapse}

Post-synaptic response components define the effect imposed on the
post-synaptic cell dynamics by triggering the synaptic input. This
definition includes only the shape of this effect and does not include the
exact magnitude of the effect. The magnitude is described separately through
plasticity rules and synaptic weights in section \ref{plasticity}. Note
though that the units of the effect are defined here and synaptic weights in
plasticity nodes are left dimensionless.

\subsection{Projection}
\label{projections}

A projection holds a description of the connectivity between two
cells. The projection does not create any new components. The purpose of
projection object is to bind source and destination components using
a certain plasticity rule and post-synaptic response.

\begin{table}[htb]
\center
\begin{tabular}{|c|}
\hline
\hline
Projection \\
\hline
\hline
{\em label}: {\tt String} \\
\hline
{\em source}: {\tt Component->Neuron} \\
\hline
{\em destination}: {\tt Component->Neuron} \\
\hline
{\em synapse}: {\tt Component->PSR} \\
\hline
{\em plasticity}: {\tt Component->Plasticity} \\
\hline
{\em note}: \{{\tt String}$|${\tt URL}\} (optional)\\
\hline
\end{tabular}
\end{table}

Projection description includes references to a plasticity component
that controls the synaptic weight (section \ref{plasticity}) and
post-synaptic response node that controls the influence of the input
through this projection on the post-synaptic cell dynamics (section
\ref{secSynapse}). Both appear in the description of the projection
rather than neuron because the same type of neuron can use different
synapses, similarly the same postsynaptic response can be used in
multiple projections with different plasticity rules. Instead of providing
the user with all possible pre-wired combinations, NineML allows user
to combine the plasticity$\rightarrow$response$\rightarrow$neuron
chain from a set of small standard components.

\subsection{Diagram}

To handle events and spiking dynamics, but also domains of continuous
dynamics, we propose a flexible block diagram notation.  The notation
represents continuous and discrete variables, their evolution
according to a set of rules such as a system of ordinary differential
equations, a \nmlClass{Regime}, and the conditions that induce a change of
Regime and/or discontinous changes in Regime state variables, a
\nmlClass{Transition}, such as the transition from subthreshold to
spiking and refractory modes.

\subsubsection{Names}

Objects of the following classes are bound to a name in a \nmlClass{Container}:
\nmlClass{StateVariable}, \nmlClass{Parameter}, \nmlClass{Binding},
\nmlClass{Port}, \nmlClass{Regime}, \nmlClass{Container}.

\subsubsection{Summary of Objects}

% TODO (using LaTeX packages uml, or pst-uml ?)
A bunch of UML diagrams of all the objects, and how they hook up to each other.

\subsubsection{\label{nml_lib}Libraries of Functions and Operations}

% TODO
RNGs, Special Functions, Logical Ops, Relational Ops, etc.
% Probably we want to put the detailed reference in an Appendix.

\subsubsection{Global Operations}

Most implementations will want to introduce syntactic sugar for
standard mathematical, logical, relational operations as well as
exposing globally a subset of frequently occuring standard constants
($e$, $pi$, etc.) and functions ($\sin(x)$, $\cos(x)$, $\exp(x)$,
etc.).

\section{Structure of a NineML Description}

In order to simplify the descriptions themselves and the mechanisms for
combining multiple components of the model the NineML description
is consisting of multiple files that define various components and
contains the syntax to import external files.

\subsection{Scope of NineML Descriptions}
\label{scope}

Elements of {\tt Regime}s and {\tt Transition}s resolve state
variables, parameters, etc. relative to their containing
{\tt Component}/{\tt Namespace} first, then the system {\tt Namespace}.

The system {\tt Namespace} is immutable, and contains:
\begin{itemize}
\item[-]{SignalLib/MathLib (pi, e, sin, cos)}
\item[-]{RandomLib}
\item[-]{DiagramLib ({\tt Regime}, {\tt Transition}, {\tt ODE},
{\tt Assignment})}
\item[-]{IntervalLib}
\item[-]{etc.}
\end{itemize}

[TODO:
Flesh this out
Who: Ivan
]

In order to avoid the collisions of user-given IDs as well as to
provide the user with the ability to redefine some of the imported
components the following set of rules is suggested:
\begin{itemize}
\item{Every identifier is considered unique only within its parent}
\item{To access the identifier a full path from the point of access
to this identifier shall be provided.}
\item{Any imported construct can be redefined within the importing
description by adding a new definition of the same object. All properties
of the imported object are imported from external file and the values of
some (or even all) of them are overwritten by the local description.}
\item{If multiple redefinitions of the same entity are found, then the most
recent one will be used. The most recent is determined by the order of
parsing of the top level model description file. Here the rule shall be
enforced that when multiple files are included all nodes are parsed before
all groups. This will allow a smooth transition from networks with simple
nodes and groups to networks where some nodes and some groups are redefined.}
\item{If several different subfields are redefined in different places of the
description, then all of these new definitions will be used. Please note that
this is not the optimal way, and the better way to achieve the same effect is
to provide all redefinitions in a unique location. Simulation software
developers can (but at this point of time are not obliged to) optimize the
NineML code that is output by their software by grouping all redefinitions
of components of the same node into a single node.}
\end{itemize}

\newpage
\appendix

\part*{Appendix}
\addcontentsline{toc}{part}{Appendix}

\section{INCF Task Force}

An oversight committee has been setup to guide the direction and
objectives of the initiative with membership as follows:

\begin{itemize}
    \item Chair: Erik De Schutter, Okinawa Institute of Science and Technology, Japan
    \item Ad Aertsen, Bernstein Center, Freiburg, Germany
    \item Upinder Bhalla, National Center for Biological Sciences, Bangalore, India
    \item Nicolas Brunel, CNRS-Université René Descartes, Paris, France
    \item Sharon Crook, Arizona State University, Tempe, USA
    \item Gustavo Deco, Universitat Pompeu Fabra, Barcelona, Spain
    \item Markus Diesmann, RIKEN, Wako, Japan
    \item Tomoki Fukai, RIKEN, Wako, Japan
    \item Wulfram Gerstner, LCN, EPFL, Lausanne, Switzerland
    \item Stephen Grossberg, Boston University, MA, USA
    \item Rolf Kötter, Radboud University, Nijmegen, The Netherlands
    \item Anders Lansner, Royal Institute of Technology (KTH), Stockholm, Sweden
    \item Peter Latham, Gatsby Computational Neuroscience Unit, London, UK
    \item Christiane Linster, Cornell University, Ithaca, NY, USA
    \item Wolfgang Maass, Technische Universität Graz, Austria
    \item Ernst Niebur, Johns Hopkins University, Baltimore, MD, USA
    \item Felix Schürmann, EPFL, Lausanne, Switzerland
    \item Simon Thorpe, Faculté de Médecine de Rangueil, Toulouse, France
    \item Alessandro Treves, International School for Advanced Studies (SISSA), Trieste, Italy
    \item Shiro Usui, RIKEN, Wako, Japan
    \item Mark van Rossum, University of Edinburgh, UK
    \item Xiao-Jing Wang, Yale University, New Haven, CT, USA
\end{itemize}

A task force has been assembled to evaluate and implement the
recommendations of the oversight committee with membership as follows:

\begin{itemize}
    \item Lead: Sean Hill, BMI, EPFL, Lausanne, Switzerland
    \item Lead: Anatoli Gorchetchnikov, Boston University, USA
    \item Lead: Ivan Raikov, Okinawa Institute of Science and Technology, Japan
    \item Board Secretary: Yann Le Franc, University of Antwerp, Belgium
    \item Robert Cannon, Textensor Limited, Edinburgh, UK
    \item Robert Clewley, Georgia State University, Atlanta, USA
    \item Hugo Cornelis, University of Texas Health Science Center, San Antonio, USA
    \item Andrew Davison, CNRS, Gif-sur-Yvette, France
    \item Erik De Schutter, Okinawa Institute of Science and Technology, Okinawa, Japan
    \item Mikael Djurfeldt, INCF Secretariat and PDC,
Royal Institute of Technology, Stockholm, Sweden
    \item Padraig Gleeson, University College London, UK
    \item Michael Hines, Yale University, New Haven, CT, USA
    \item Birgit Kriener, Max Planck Institute for Dynamics and Self-Organization,
Göttingen, Germany
    \item Chung-Chuan Lo, National Tsing Hua University, Hsinchu, Taiwan
    \item Abigail Morrison, Bernstein Center Freiburg, Germany
    \item Eilif Muller, LCN, EPFL, Lausanne, Switzerland
    \item Hans Ekkehard Plesser, Norwegian University of Life Sciences, Aas, Norway
    \item Subhasis Ray, National Center for Biological Sciences, Bangalore, India
    \item Lars Schwabe, University of Rostock, Germany
    \item Botond Szatmary, Neurosciences Institute, San Diego, CA, USA

\end{itemize}

and thus includes the authors or primary contributors to a wide
variety of computational neuroscience efforts including the Blue Brain
Project, GENESIS-3, KInNeSS, MOOSE, NEURON, NEST, PyNN and NeuroML.

\bibliographystyle{apalike}
%\bibliography{CondensedUL}

\end{document}
